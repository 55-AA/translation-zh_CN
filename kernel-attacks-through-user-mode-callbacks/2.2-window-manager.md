# 2.2. 窗口管理器

窗口管理器的重要作用之一就是记录用户实体，像窗口，菜单，光标等等。
为了记录它们在用户会话中的使用，
窗口管理器将这些实体表示为用户对象并维护它自己的句柄表。
因此，当应用程序请求对用户实体执行操作时，
窗口管理器会提供句柄值，句柄值由句柄管理器映射到内核内存中对应的对象。

## 用户对象

用户对象具有不同的类型，并且因此拥有各自特定的结构。
举个例子，所有的窗口对象都由 win32k!tagWND 结构定义，
而所有的菜单都由 win32k!tagMENU 结构定义。
尽管对象类型在结构上不同，但它们都有一个的 HEAD 结构的头部（__清单 1__）。

HEAD 结构保存句柄值的一个复本（h）和一个锁计数（cLockObj），
如果对象被引用，该计数会增加。当对象不再被特定的组件引用时，
该计数会减少。当锁计数为 0 的时候，窗口管理器就认为该对象不再被使用并将其释放。

```
typedef struct _HEAD {
     HANDLE         h;
     ULONG32        cLockObj;
} HEAD, *PHEAD;
```

__清单 1__ HEAD 结构

尽管 HEAD 结构很小，对象经常使用更大的线程或进程特定的头部结构，
比如 THRDESKHEAD 与 PROCDESKHEAD。这些结构提供更多的成员，
像指向线程信息结构 tagTHREADINFO 的指针与指向相关联的桌面对象
（tagDESKTOP）的指针。通过提供这些信息，Windows
可以限制对其他桌面对象的访问，因而实现了桌面与桌面之间的隔离。
类似地，由于对象通常由一个线程或进程所拥有，
所以存在于同一个桌面的线程或者进程之间的隔离也可以实现。
举个例子，一个特定的线程不能简单地通过调用 DestroyWindow
销毁其他线程的窗口对象。相反，它需要发送窗口消息，
而这个消息需要经过额外的检查，像完整性等级检查。不过，
由于对象隔离不是以统一、集中地方式提供，
那些不实施必要的检查的函数可能使地攻击者绕过这一限制。
不可否认的是，这是在高特权的服务与已经记录的服务之间引入会话隔离
（Windows Vista 及其以后）的原因之一。
因为在同一个会话的所有进程和线程共用同一个用户句柄表，
所以低特权进程可能传递消息或者与高特权进程所拥有的对象交互。

## 句柄表

所有用户对象都索引在每次会话的句柄表中。
句柄表由 win32k!Win32UserInitialize 初始化，
每当新的 Win32k 实例加载时，该函数就会被调用。
句柄表本身存储在一个也由 Win32UserInitialize
初始化的共享区段的基址（win32k!gpvSharedBase）。
这个区段后来会映射到每一个新的 GUI 进程，
因而可以让进程不借助系统调用就能从用户模式访问到句柄表。
将共享区段映射到用户模式被看作是性能好处，
为了避免在客户端应用程序与 CSRSS 之间的大量情景切换，
这种做法同样应用到了不基于内核的 Win32 子系统的设计当中。
在 Windows 7 中，指向句柄表的指针存储在共享信息结构
（win32k!tagSHAREDINFO）。
指向这个结构的指针即存在于用户模式
（user32!gSharedInfo【__注 3__】）
也存在于内核模式（win32k!gSharedInfo）。

__注 3__：只适用于 Windows 7

```
typedef struct _HANDLEENTRY {
      struct _HEAD* phead;
      VOID*         pOwner;
      UINT8         bType;
      UINT8         bFlags;
      UINT16        wUniq;
} HANDLEENTRY, *PHANDLEENTRY;
```
__清单 2__ HANDLEENTRY 结构

用户句柄表中的项由 HANDLEENTRY 结构
（__清单 2__）表示。具体地讲，该结构包含对象特定于一个句柄的信息，
像指向对象自己的指针（phead），
对象的拥有者（pOwner）与对象的类型（bType）。
对象的拥有者（pOwner）要么是指向线程或者进程信息结构的指针；
要么是 NULL，表明对象是全局的，实际的例子有显示器、
键盘布局或者文件对象，它们在会话里是全局的。

用户对象的实际类型由 bType 的值定义，
并且在 Windows 7 中这个值的范围是 0 到 21
（__表 1__）。bFlags 定义额外的对象标记，
通常用来确定对象是否已经销毁。举个例子，一个对象被请求销毁，
但是由于锁计数不是为 0 依旧留在内存里。
最后，wUniq 的值用作计算句柄值的独特性计数器。
句柄值这样产生：句柄 = 表项 id | (wUniq << 0x10)。
当一个对象被释放时，为了避免后续的对象立即重用之前的句柄，
该计数器会自增。应当注意的是，这个机制不能认为是一种安全特性。
原因是 wUniq 这个计数器只有 16 比特，当足够多的对象被分配、
释放时，该计数器会溢出。

```
ID         类型                      拥有者                 内存位置
0          自由类型
1          窗口                     线程                 桌面堆 / 会话池
2          菜单                     进程                 桌面堆
3          光标                     进程                 会话池
4          设置窗口位置              线程                 会话池
5          钩子                     线程                 桌面堆
6          剪切板数据 Data                               会话池
7          调用过程数据              进程                 桌面堆
8          加速器                   进程                 会话池
9          DDE 访问                 线程                 会话池
10         DDE 对话                 线程                 会话池
11         DDE 交易                 线程                 会话池
12         显示器                                        共享堆
13         键盘布局                                      会话池
14         键盘文件                                      会话池
15         事件钩子                  线程                 会话池
16         计时器                                        会话池
17         输入设备表                线程                 桌面堆
18         Hid 数据                 线程                 会话池
19         设备信息                                      会话池
20         触摸（Win 7）             线程                 会话池
21         手势（Win 7）             线程                 会话池
```

__表 1__ 用户对象的拥有者与内存位置

为了确定句柄的有效性，窗口管理器可能会调用
HMValidateHandle 中的 API。这些函数接受一个句柄值与句柄类型作为参数，
并查询句柄表中的对应项。如果对象具有请求的类型，
函数会返回指向对象的指针。

## 内存中的用户对象

在 Windows 里，用户对象与它们关联的数据结构可能位于桌面堆，
共享堆或者会话池。通常的规律是，与特定桌面关联的存储在桌面堆，
其余的在共享堆或者会话池。不过，每种对象实际的位置由句柄类型信息表
（win32k!ghati）定义。该表包含特定于每种对象的属性，
句柄管理器在分配或者释放用户对象的时后会使用该表。具体地讲，
句柄类型信息表的项由未公开的结构（这里也没有列出来）定义，
该结构含有对象分配标签，类型标记，指向该类型特定销毁例程的指针。
当对象的锁计数为 0 的时侯，该例程就会被调用，
即窗口管理器通过调用这个类型特定的销毁例程来正确的释放对象。

## 临界区

不同于由 NT 执行体管理的对象，
窗口管理器并不会排斥地锁住每一个用户对象。相反，
它使用一个位于 Win32k 的临界区（资源）实现每次会话的全局锁。
具体地讲，每个操作用户对象或者用户管理结构的内核例程
（典型的像 NtUser 系统调用）必须先进入用户临界区
（即获得 win32k!gpresUser 资源）。举个例子，
更新内核模式结构的函数必须先调用UserEnterUserCritSec，
并获得用于排斥访问的用户资源，然后才能修改数据。
为了减少窗口管理器中锁的介入次数，只做读操作的系统调用使用共享临界区
（EnterSharedCrit）。这使得 Win32k 能够实现某种并行，
哪怕设计上有全局锁，因为多个线程可能并发地执行 NtUser 的调用。
