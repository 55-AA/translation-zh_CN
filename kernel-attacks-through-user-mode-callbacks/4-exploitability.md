# 4. 可利用性

在这一节，我们评估用户模式回调函数引起的漏洞的可利用性。
由于我们主要关心两类漏洞：释放后重用与零指针解引用，
所以我们只关注攻击者在利用 Win32k 漏洞时利用这类漏洞的难度。
评估漏洞的可利用性对于提出合理的缓解方法是至关重要的。

## 4.1. 内核堆

正如在 2.2 节中提到的那样，用户对象与它们相关的数据结构可能存储在会话池，
共享堆，桌面堆。存储在桌面堆或者共享堆的对象与数据结构由内核堆分配器管理。
内核堆分配器可以被认为是用户模式堆分配器的精简版，并且使用熟悉的类似
RtlAllocateHeap 与 RtlFreeHeap 的由 NT 执行体导出的函数管理堆块。

尽管用户堆和内核堆十分相似，它们依旧存在一些关键的差别。不同于用户模式的堆，
Win32k 使用的内核堆并不采用任何前端分配器。这可以通过查看被堆基址
（HEAP）引用的 HEAP\_LIST\_LOOKUP 结构的 ExtendedLookup 值。
当设置为 NULL 的时候，堆分配器不会使用任何的旁视列表或者低碎片堆堆。
此外，在转储栈基址结构（__清单 18__）的时候，
我们可以观察到堆管理结构没有采用任何编码或者混淆，
因为 EncodingFlagMask 与 PointerKey 都被设置为 NULL。
前者决定是否使用堆头部编码，而后者用于编码当堆需要拓展的时候回调用的
CommitRoutine 指针。

```
kd> dt nt!_HEAP fea00000
    ...
    +0x04c EncodeFlagMask        :  0
    +0x050 Encoding              :  _HEAP_ENTRY
    +0x058 PointerKey            :  0
    ...
    +0x0b8 BlocksIndex           :  0xfea00138 Void
    ...
    +0x0c4 FreeLists             :  _LIST_ENTRY [ 0xfea07f10 - 0xfea0e4d0 ]
    ...
    +0x0d0 CommitRoutine         :  0x93a4692d  win32k!UserCommitDesktopMemory
    +0x0d4 FrontEndHeap          :  (null)
    +0x0d8 FrontHeapLockCount       : 0
    +0x0da FrontEndHeapType :       0 ’’
kd> dt nt!_HEAP_LIST_LOOKUP fea00138
    +0x000 ExtendedLookup        : (null)
    ...
```

__清单 18__ 桌面堆基址与 BlocksIndex 结构

在处理像释放后重用的内核堆破坏时，清楚的知道内核堆管理器如何工作是至关重要的。
有许多很棒的文章讲述用户模式堆实现的内部工作原理，
它们可以作为学习内核堆的参考。就本文的讨论而言，
知道内核堆是一块可以根据分配的内存拓展与收缩的连续内存就够了。
因为没有采用前端管理器，所有的可用块都索引到一个单一的可用列表中。
作为一个通用的规则，为了更好的利用 CPU 缓存，
堆管理器总是尝试分配最近释放的块（比如通过使用列表的提示）。

## 4.2. 释放后重用漏洞的利用

为了利用 Win32k 里的释放后重用漏洞，
攻击着需要能够重新分配已经被释放的内存与对其内容一定程度上的控制。
因为用户对象与相关的数据结构是与字符串一起存储的，
通过设置存储为 Unicode 字符串的对象属性可以实现任意大小的分配
与对最近释放内存内容的完全控制。只要能够避免 NULL，
字节组合就能用来操纵那些作为对象或者数据结构访问的内存。
对于桌面堆上面的释放后重用漏洞，攻击者可能通过调用
SetWindowTextW 设置窗口的任务栏来强制实现任意大小的桌面堆分配。
类似地，任意大小的会话池分配可以通过调用 SetClassLongPtr
并将 GCLP\_MENUNAM 设置为与窗口类关联的菜单资源的菜单名字字符串实现。

```
eax=41414141 ebx=00000000 ecx=ffb137e0 edx=8e135f00 esi=fe74aa60 edi=fe964d60
eip=92d05f53 esp=807d28d4 ebp=807d28f0 iopl=0                  nv up ei pl nz na pe cy
cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000                            efl=00010207
win32k!xxxSetPKLinThreads+0xa9:
92d05f53 89700c      mov     dword ptr [eax+0Ch],esi ds:0023:4141414d=????????
kd> dt win32k!tagKL @edi -b
    +0x000 head                 : _HEAD
       +0x000 h                     : 0x41414141
       +0x004 cLockObj              : 0x41414142
    +0x008 pklNext              : 0x41414141
    +0x00c pklPrev              : 0x41414141
    ...
```

__清单 19__ 字符串作为键盘布局对象（CVE-2011-1241）

在 __清单 19__ 中（在 3.2 节里描述的漏洞），
键盘布局对象被用户控制的分配在桌面堆上的字符串替换掉了。
在这个特定的例子里，键盘布局对象已经释放，
但是 Win32k 尝试将它连接到键盘布局对象列表里。
这就使得攻击者可以通过控制已经释放掉的键盘布局对象里的
pklNext 来选择 esi 所写入的地址

由于对象通常包含指向其他对象的指针，Win32k
采用赋值锁来确保对象依赖能够满足。
这样，影响那些包含赋值锁住了的指针的对象的释放后重用
可能允许攻击者实现减少任意地址的值，
因为 Win32k 会尝试释放那个对象引用。一种可能的利用方式是在
【参考文献 11】中描述的攻击的变种。在【参考文献 11】中，
用户模式回调函数返回了一个被销毁的菜单句柄索引。
当线程结束是，这导致自由类型（0）的销毁例程被调用。
因为自由类型没有定义销毁例程，Win32k 会调用用户模式可以映射的
NULL 页面（参见 4.3. 节）。

```
eax=deadbeeb ebx=fe954990 ecx=ff910000 edx=fea11888 esi=fea11888 edi=deadbeeb
eip=92cfc55e esp=965a1ca0 ebp=965a1ca0 iopl=0                nv up ei ng nz na pe nc
cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000                          efl=00010286
win32k!HMUnlockObject+0x8:
92cfc55e ff4804              dec      dword ptr [eax+4]      ds:0023:deadbeef=????????
965a1ca0   92cfc9e0  deadbeeb  00000000  fe954978  win32k!HMUnlockObject+0x8
965a1cb0   92c60cb1  92c60b8b  004cfa54  002dfec4  win32k!HMAssignmentLock+0x45
965a1cc8   92c60bb3  965a1cfc  965a1cf8  965a1cf4  win32k!xxxCsDdeInitialize+0x67
965a1d18   8284942a  004cfa54  004cfa64  004cfa5c  win32k!NtUserDdeInitialize+0x28
965a1d18   779864f4  004cfa54  004cfa64  004cfa5c  nt!KiFastCallEntry+0x12a
```

__清单 20__ 字符串作为 DDE 对象（CVE-2011-1242）

由于攻击者可能推断出用户句柄表在内核内存中的地址，
攻击者进而能够减少一个窗口对象句柄表项（1）的类型值
（bType）。当销毁窗口时，这会导致自由类型（0）的销毁例程被调用，
进而实现内核任意代码执行。在清单 20，攻击者控制赋值锁锁住的指针，
造成任意内核地址减少。

## 4.3. 零指针解引用漏洞的利用

不用其他的系统，比如 Linux，Windows（为了保持后向兼容性）
允许非特权的用户在用户进程的情境下映射 NULL 页面。
因为内核与用户模式组件共享同样的虚拟地址空间，
攻击者可能可以通过映射 NULL 页面并且控制被解引用的数据来利用内核
NULL 指针解引用漏洞。为了在 Windows 上分配 NULL 页面，
应用程序可以简单地调用 NtAllocateVirtualMemory 并请求一个
比 NULL 大但是比一个页面大小小的基址。
应用程序也可以通过调用 NtMapViewOfSection
使用类似的基址并使用 MEM\_DOS\_LIM
兼容性标志启用页面对齐区段（只用于 x86）来内存映射 NULL 页面。

Win32k 里的 NULL 指针解引用漏洞大多是由不充分的堆用户对象指针检查造成的。
因此，攻击者可能可以通过创建伪造的 NULL
页面对象并接着触发任意内存写或者控制一个函数指针的值来利用这类漏洞。
举个例子，由于最近 Win32k 里的许多的零指针解引用漏洞都是与窗口对象指针有关，
攻击者可能放置一个伪造的窗口对象在 NULL 页面，
并定义一个自定义的服务端窗口过程（__清单 21__）。
如果有任何消息传递到了那个 NULL 对象上。
这将使得攻击者得到任意内核代码执行的能力

```
pwnd = (PWND) 0;
pwnd->head.h = hWnd; // valid window handle
pwnd->head.pti = NtCurrentTeb()->Win32ThreadInfo;
pwnd->bServerSideWindowProc = TRUE;
pwnd->lpfnWndProc = (PVOID) xxxMyProc;
```

__清单 21__ 在 NULL 页面设置一个伪造的窗口对象
