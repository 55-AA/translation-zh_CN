# 5. 缓和

在这一节我们评估用来缓和在第 4 节中讨论的几种漏洞类型的方法。

## 5.1. 释放后重用漏洞

正如在前面的小节里提到的那样，
释放后重用漏洞依赖于攻击者具有重新分配并控制之前释放的内存的能力。
不幸地是，因为 CPU 没有办法区分内存是否属于某个特定的对象或者数据结构
（这是操作系统做出的抽象），尝试缓和释放后重用漏洞是非常困难的。
如果我们更进一步的看这个问题，这些问题本质上是因为在处理用户模式回调函数的时候，
攻击者能够释放对象或者缓冲区，并且在它被 Win32k 再次使用之前重新分配内存。
因此降低内核池或者堆分配的可预测性或者隔离特定的分配使得容易
被控制的原始语比如字符串不会从同样的资源，也就是用户对象，中分配。

由于操作系统能在回调函数活动（比如通过 KTHREAD.CallbackDepth）的时候感知到，
在处理回调的时候可以采用延迟释放的方法。这将阻止攻击者立即重用释放掉的内存。
但是这样子的机制不能阻止在释放后重用条件触发之前，
多次连续调用用户模式回调函数的情况。另外，
因为用户模式回调机制不是在 Win32k.sys 里实现，
所以需要在回调函数返回的时候实现额外的逻辑来完成必要的延迟释放列表处理。

不是以专注分配可预测性来应对释放后重用问题，我们可以查看典型的利用是如何执行的。
正如在第 4 节中讨论的那样，Unicode 字符串与一大部分数据可以被控制的分配
（像定义了 cbWndExtra 的窗口对象）对攻击者是非常有利的。
因此，隔离这样子的分配可以用来阻止攻击者采用灵活的攻击原始语
轻松地实现已经释放对象的内存的重新分配（比如字符串）。

## 5.2. 零指针解引用漏洞

为了应对 Windows 上的零指针解引用漏洞利用，
我们需要拒绝用户模式应用程序映射与控制 NULL 页面的能力。
尽管有多种方式可以解决这个问题，比如通过系统调用挂钩
【__注 7__】或者页面表项（PTE）修改，但是采用虚拟地址描述符
（VAD）似乎更合适。因为 VAD 描述进程内存空间并提供 Windows
正确设置好页面表项所需要的信息，它们可以用来以一种统一与通用的方式阻止
NULL 页面映射。然而，因为 32 位 Windows 里的 NTVDM
依赖这样的能力来正确的设置 16 位可执行程序
，阻止 NULL 页面映射也牺牲了后向兼容性。

__注 7__：微软不鼓励使用系统调用挂钩并且在 64
位系统上由于内核补丁保护强制的完整性检查不容易实现。
